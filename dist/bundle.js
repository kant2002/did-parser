/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (() => {

eval("var TOKEN_TYPES = [\n    { name: 'IDENTIFIER', pattern: /[a-zA-Zа-яА-Яіʼ_]+/u },\n    { name: 'EQUALS', pattern: /=/ },\n    { name: 'STRING', pattern: /\"[^\"]*\"/ },\n    { name: 'NUMBER', pattern: /\\d+/ },\n    { name: 'LPAREN', pattern: /\\(/ },\n    { name: 'RPAREN', pattern: /\\)/ },\n    { name: 'COMMA', pattern: /,/ },\n    { name: 'NEWLINE', pattern: /\\n/ },\n    { name: 'WHITESPACE', pattern: /\\s+/ },\n];\nvar Token = /** @class */ (function () {\n    function Token(type, value) {\n        this.type = type;\n        this.value = value;\n    }\n    return Token;\n}());\nvar Lexer = /** @class */ (function () {\n    function Lexer(inputString) {\n        this.inputString = inputString;\n        this.position = 0;\n    }\n    Lexer.prototype.getNextToken = function () {\n        if (this.position >= this.inputString.length) {\n            return new Token('EOF', null);\n        }\n        for (var _i = 0, TOKEN_TYPES_1 = TOKEN_TYPES; _i < TOKEN_TYPES_1.length; _i++) {\n            var tokenType = TOKEN_TYPES_1[_i];\n            var regex = new RegExp(\"^\".concat(tokenType.pattern.source));\n            var match = this.inputString.slice(this.position).match(regex);\n            if (match) {\n                var value = match[0];\n                var token = new Token(tokenType.name, value);\n                this.position += value.length;\n                return token;\n            }\n        }\n        throw new Error(\"Invalid input at position \".concat(this.position, \": \").concat(this.inputString.slice(this.position)));\n    };\n    return Lexer;\n}());\nvar Parser = /** @class */ (function () {\n    function Parser(lexer) {\n        this.lexer = lexer;\n        this.currentToken = this.lexer.getNextToken();\n    }\n    Parser.prototype.tryConsume = function (type) {\n        if (this.currentToken.type === type) {\n            //console.log(`Consume ${type}, ${this.currentToken.value}`);\n            this.currentToken = this.lexer.getNextToken();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Parser.prototype.consume = function (type, skipWhitespaces) {\n        if (skipWhitespaces === void 0) { skipWhitespaces = true; }\n        if (!this.tryConsume(type)) {\n            throw new Error(\"Unexpected token: \".concat(this.currentToken.type, \" (expected \").concat(type, \")\"));\n        }\n        if (skipWhitespaces) {\n            while (this.tryConsume('WHITESPACE') || this.tryConsume('NEWLINE')) {\n            }\n        }\n    };\n    Parser.prototype.parse = function () {\n        var objectValue = {};\n        var typeName = this.currentToken.value;\n        this.consume('IDENTIFIER');\n        this.consume('LPAREN');\n        while (this.currentToken.type !== 'RPAREN') {\n            var propertyName = this.currentToken.value;\n            this.consume('IDENTIFIER');\n            this.consume('EQUALS');\n            var propertyValue = this.parseValue();\n            objectValue[propertyName] = propertyValue;\n            if (this.currentToken.type === 'COMMA') {\n                this.consume('COMMA');\n            }\n        }\n        this.consume('RPAREN');\n        objectValue.$type = typeName;\n        return objectValue;\n    };\n    Parser.prototype.parseBool = function () {\n        if (this.currentToken.type !== 'IDENTIFIER') {\n            throw new Error(\"Unexpected token: \".concat(this.currentToken.type));\n        }\n        if (this.currentToken.value !== 'так' && this.currentToken.value !== 'ні') {\n            throw new Error(\"Unexpected bool value, but \".concat(this.currentToken.value, \" was given\"));\n        }\n        this.consume('IDENTIFIER');\n        return this.currentToken.value === 'так';\n    };\n    Parser.prototype.parseValue = function () {\n        var propertyValue;\n        if (this.currentToken.type === 'STRING' || this.currentToken.type === 'NUMBER') {\n            propertyValue = this.currentToken.value.slice(1, -1);\n            this.consume(this.currentToken.type);\n        }\n        else if (this.currentToken.type === 'IDENTIFIER') {\n            if (this.currentToken.value !== 'так' && this.currentToken.value !== 'ні') {\n                propertyValue = this.parse();\n            }\n            else {\n                propertyValue = this.parseBool();\n            }\n        }\n        else if (this.currentToken.type === 'LPAREN') {\n            propertyValue = this.parseObject();\n        }\n        else if (this.currentToken.type === 'COMMA') {\n            //propertyValue = this.parseObject();\n        }\n        else {\n            throw new Error(\"Unexpected token: \".concat(this.currentToken.type));\n        }\n        return propertyValue;\n    };\n    Parser.prototype.parseObject = function () {\n        this.consume('LPAREN');\n        var object = this.parse();\n        this.consume('RPAREN');\n        return object;\n    };\n    return Parser;\n}());\nvar lexer = new Lexer(\"\\u041F\\u0430\\u0441\\u043F\\u043E\\u0440\\u0442(\\n    \\u043F\\u0440\\u0456\\u0437\\u0432\\u0438\\u0449\\u0435=\\\"\\u041A\\u043E\\u0433\\u0443\\u0442\\\",\\n    \\u0456\\u043C\\u02BC\\u044F=\\\"\\u0414\\u0430\\u0432\\u0438\\u0434\\\",\\n    \\u043F\\u043E_\\u0431\\u0430\\u0442\\u044C\\u043A\\u043E\\u0432\\u0456=\\\"\\u0411\\u043E\\u0433\\u0434\\u0430\\u043D\\u043E\\u0432\\u0438\\u0447\\\",\\n    \\u0434\\u0430\\u0442\\u0430_\\u043D\\u0430\\u0440\\u043E\\u0434\\u0436\\u0435\\u043D\\u043D\\u044F=\\u0414\\u0430\\u0442\\u0430(\\n      \\u0434\\u0435\\u043D\\u044C=20,\\n      \\u043C\\u0456\\u0441\\u044F\\u0446\\u044C=1,\\n      \\u0440\\u0456\\u043A=2001\\n    ),\\n    \\u0437\\u0430\\u0441\\u0442\\u0430\\u0440\\u0456\\u043B\\u0438\\u0439=\\u043D\\u0456\\n  )\\n\");\nvar parser = new Parser(lexer);\nconsole.log(parser.parse());\n\n\n//# sourceURL=webpack://did-parser/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.ts"]();
/******/ 	
/******/ })()
;